\documentclass[12pt]{article}

\usepackage{times}
\usepackage[cm]{fullpage}

\setlength{\parskip}{6pt}
\setlength{\parindent}{0pt}

\begin{document}

We will get an object x.methy450 with slots for the gene region level summary.

<<set options, cache = FALSE, echo = TRUE, include = FALSE>>=
options(width = 60)
library(IMA)
library(doParallel)
library(foreach)
cl <- makeCluster(12)
registerDoParallel(cl)

@

<<setup mvalues, pData, hm450, cache = TRUE, echo = FALSE, include = FALSE>>=
#load the mvalues, annotation, pvalue, and hm450 matrix 
load("/proj/design/il450k/nest13/R/MvalueAnalysisStructures.RData")

dim(mvalues)
dim(hm450)
dim(pData)
dim(annot)
table(rownames(pData) == pData$nestid)

#load the behavioral scores
epi<-read.csv("NESTSR_IVERSEN_8_22_15.csv", as.is=TRUE)
dim(epi)
length(unique(epi$nestid)) == nrow(epi)
rownames(epi) <-epi$nestid

#merge patient info (race, age, etc) with behaviroal scores
table(keep<-rownames(pData) %in% rownames(epi))
pData<-pData[keep,]
mvalues<-mvalues[,keep]
epi <- epi[rownames(pData),]
colnames(epi)[colnames(epi) %in% colnames(pData)]
pData<-cbind(pData,epi[,colnames(epi) != "nest_id"])
rm(epi)

#delete rows for which we do not have mother's ADHD data
keep <- (!is.na(pData$asrs_ADHD))
pData <- pData[keep,]
mvalues <- mvalues[,keep]
dim(mvalues)
rm(keep)

#mvalues which have less than 
table(hm450$KeepHalfPct)
table(rownames(hm450)==rownames(mvalues))
mvalues<-mvalues[hm450$KeepHalfPct,]
hm450<-hm450[hm450$KeepHalfPct,]
table(rownames(hm450)==rownames(mvalues))

#create categorical variables for mother's ADHD, education, parity, and pre-pregnancy BMI
pData$asrs_ADHD_2cat <- factor(pData$asrs_ADHD, labels = 0:1, levels = 0:1)
pData$education_3cat<- factor(pData$education_3cat, labels = 1:3, levels = 1:3)
pData$parity_3cat <- factor(pData$parity_3cat, labels = 0:2, levels = 0:2)
pData$prePregBMIthreeLev <- rep(NA, nrow(pData))
pData$prePregBMIthreeLev[(!is.na(pData$BMI_LMP_kgm2)) & (pData$BMI_LMP_kgm2 < 30)] <- 0
pData$prePregBMIthreeLev[(!is.na(pData$BMI_LMP_kgm2)) & (pData$BMI_LMP_kgm2 >= 30) & (pData$BMI_LMP_kgm2 < 35)] <- 1
pData$prePregBMIthreeLev[(!is.na(pData$BMI_LMP_kgm2)) & (pData$BMI_LMP_kgm2>=35)] <- 2
pData$prePregBMIthreeLev <-factor(pData$prePregBMIthreeLev, levels = 0:2, labels = c("Lt30", "30toLt35", "Ge35"))
@

<<setup exprmethy450 class, cache = TRUE, echo = FALSE, include = FALSE>>=
##this script will provide the summary statistics for the methy450 object
##first we make exprmethy450 class with bmatrix, annot, detectP matrix, and pData data frame

##set rownames of pData to colnames of mvalues which is the barcode plus row & column
rownames(pData) <- colnames(mvalues)
##create a pDetect matrix
detect_p <- matrix(1, nrow = dim(mvalues)[1], ncol = dim(mvalues)[2])
colnames(detect_p) <- colnames(mvalues)
#the first column of the hm450 matrix is "IlmnID"

setClass("exprmethy450", representation(bmatrix = "matrix",
        annot = "matrix", detectP = "matrix", groupinfo = "data.frame"),
        where = topenv(parent.frame()))
x.methy450 = new("exprmethy450", bmatrix = as.matrix(mvalues),
    annot = as.matrix(hm450), detectP = as.matrix(detect_p),
    groupinfo = pData)
cat("An exprmethy450 class is created and the slotNames are:\n",
        slotNames(x.methy450), "\n", fill = TRUE)

bmatrix = as.matrix(mvalues)
dim(bmatrix)
colnames(bmatrix)
detect_p = as.matrix(detect_p)
annotation = as.matrix(hm450)
groupinfo = pData

cat(".......\nSplit the annotation file to 11 
    annotated region categories\n.......\n\n", fill = TRUE)
    annot = annotation
    name = "UCSC_RefGene_Name"
    cpGsite = as.character(annot[, 1])
    genelist = strsplit(as.character(annot[, name]), ";")
    genelist[which(genelist == "character(0)")] = "NA"
	#make a list with Refgene group for each site, sometimes more than one
    #input NA for those without value
    name = "UCSC_RefGene_Group"
    refgene = strsplit(as.character(annot[, name]), ";")
    #make a list with Refgene group for each site, sometimes more than one
    refgene[which(refgene == "character(0)")] = "NA"
    listlength = lapply(refgene, length)
    listlength[listlength == 0] = 1
    col0 = rep(1:nrow(annot), listlength)
    col1 = rep(cpGsite, listlength)
    col2 = unlist(genelist)
    col3 = unlist(refgene)
    col4 = rep(as.character(annot[, "Relation_to_UCSC_CpG_Island"]), 
        listlength)
    col5 = rep(as.character(annot[, "UCSC_CpG_Islands_Name"]), 
        listlength)
##we rep the col0, 1, 2, 3 according to how many site each CpG probe is linked to 
##col0 are the indices, col1 are the Cpg probe names, col2 are the names of the
##associated genes, col3 are the name of the associated gene regions, 
##col4 are CpG site region (i.e. shelf, shore, etc.),
##col5 are the chromosomal location of the CpG islands
    splitToRegionlist = function(grepname = c("TSS1500", "TSS200", 
        "5'UTR", "1stExon", "Gene Body", "3'UTR")) {
        index = col3 == grepname
        col1sub = col1[index]
        col2sub = col2[index]
        temp = split(col1sub, col2sub)
        returnSID = lapply(temp, unique)
        col0sub = col0[index]
        temp = split(col0sub, col2sub)
        returnPID = lapply(temp, unique)
        return(Ind = list(SID = returnSID, PID = returnPID))
    }
##First list of summary stats: grouped by associated genes
    TSS1500Ind = splitToRegionlist(grepname = "TSS1500")
    TSS200Ind = splitToRegionlist(grepname = "TSS200")
    UTR5Ind = splitToRegionlist(grepname = "5'UTR")
    EXON1Ind = splitToRegionlist(grepname = "1stExon")
    GENEBODYInd = splitToRegionlist(grepname = "Body")
    UTR3Ind = splitToRegionlist(grepname = "3'UTR")

    cat("TSS1500 region contains:", length(TSS1500Ind$SID), 
        "UCSC REFGENE region \nTSS200 region contains:", 
        length(TSS200Ind$SID), "UCSC REFGENE region\n5'UTR region contains:", 
        length(UTR5Ind$SID), "UCSC REFGENE region\n1st Exon region contains:", 
        length(EXON1Ind$SID), "UCSC REFGENE region\nGene body region contains:", 
        length(GENEBODYInd$SID), "UCSC REFGENE region\n3'UTR region contains:", 
        length(UTR3Ind$SID), "UCSC REFGENE region\n", fill = TRUE)

##Second list of summary stats: grouped by chromosomal regions
    splitToRegionlist2 = function(grepname = c("Island", "N_Shore", 
        "S_Shore", "N_Shelf", "S_Shelf")) {
        index = col4 == grepname
        col1sub = col1[index]
        col5sub = col5[index]
        temp = split(col1sub, col5sub)
        returnSID = lapply(temp, unique)
        col0sub = col0[index]
        temp = split(col0sub, col5sub)
        returnPID = lapply(temp, unique)
        return(Ind = list(SID = returnSID, PID = returnPID))
    }

    ISLANDInd = splitToRegionlist2(grepname = "Island")
    NSHOREInd = splitToRegionlist2(grepname = "N_Shore")
    SSHOREInd = splitToRegionlist2(grepname = "S_Shore")
    NSHELFInd = splitToRegionlist2(grepname = "N_Shelf")
    SSHELFInd = splitToRegionlist2(grepname = "S_Shelf")

    cat("Island region contains:", length(ISLANDInd$SID), 
        "UCSC CPG ISLAND region\nN_Shore region contains", 
        length(NSHOREInd$SID), "UCSC CPG ISLAND region\nS_Shore region contains", 
        length(SSHOREInd$SID), "UCSC CPG ISLAND region\nN_Shelf region contains", 
        length(NSHELFInd$SID), "UCSC CPG ISLAND region\nS_Shelf region contains", 
        length(SSHELFInd$SID), "UCSC CPG ISLAND region\n", fill = TRUE)
    setClass("methy450batch", representation(bmatrix = "matrix", 
        annot = "matrix", detectP = "matrix", groupinfo = "data.frame", 
        TSS1500Ind = "list", TSS200Ind = "list", UTR5Ind = "list", 
        EXON1Ind = "list", GENEBODYInd = "list", UTR3Ind = "list", 
        ISLANDInd = "list", NSHOREInd = "list", SSHOREInd = "list", 
        NSHELFInd = "list", SSHELFInd = "list"), where = topenv(parent.frame()))
    x.methy450 = new("methy450batch", bmatrix = as.matrix(bmatrix), 
        annot = as.matrix(annotation), detectP = as.matrix(detect_p), 
        groupinfo = groupinfo, TSS1500Ind = TSS1500Ind, TSS200Ind = TSS200Ind, 
        UTR5Ind = UTR5Ind, EXON1Ind = EXON1Ind, GENEBODYInd = GENEBODYInd, 
        UTR3Ind = UTR3Ind, ISLANDInd = ISLANDInd, NSHOREInd = NSHOREInd, 
        SSHOREInd = SSHOREInd, NSHELFInd = NSHELFInd, SSHELFInd = SSHELFInd)
    cat("\nA methy450batch class is created and the slotNames are:\n", 
        slotNames(x.methy450), "\n", fill = TRUE) 

##check the length of the regions 
	for (slot in slotNames(x.methy450)){
        if(grepl('Ind', slot, ignore.case = TRUE)){
            print(paste0('x.methy450@', slot, '$SID'))
            print(length(eval(parse(text = paste0('x.methy450@', slot, '$SID')))))
        }
        else{
            paste0('x.methy450@', slot)
            print(dim(eval(parse(text = paste0('x.methy450@', slot)))))
        }
	}
@

<<summary_statistics, cache = TRUE, echo = FALSE, include = FALSE>>=
#Get a matrix for each region with the mean m-values
beta.cpg<- x.methy450@bmatrix
dim(beta.cpg)
rownames(beta.cpg)<-x.methy450@annot[,"IlmnID"]
beta.island <- indexregionfunc(indexlist=x.methy450@ISLANDInd,
    beta=beta.cpg,indexmethod="median")
beta.tss1500 <- indexregionfunc(indexlist=x.methy450@TSS1500Ind,
    beta=beta.cpg,indexmethod="median")
beta.tss200 <- indexregionfunc(indexlist=x.methy450@TSS200Ind,
    beta=beta.cpg,indexmethod="median")
beta.utr5 <- indexregionfunc(indexlist=x.methy450@UTR5Ind,
    beta=beta.cpg,indexmethod="median")
beta.exon1 <- indexregionfunc(indexlist=x.methy450@EXON1Ind,
    beta=beta.cpg,indexmethod="median")
beta.genebody <- indexregionfunc(indexlist=x.methy450@GENEBODYInd,
    beta=beta.cpg,indexmethod="median")
beta.utr3 <- indexregionfunc(indexlist=x.methy450@UTR3Ind,
    beta=beta.cpg,indexmethod="median")
beta.nshore <- indexregionfunc(indexlist=x.methy450@NSHOREInd,
    beta=beta.cpg,indexmethod="median")
beta.sshore <- indexregionfunc(indexlist=x.methy450@SSHOREInd,
    beta=beta.cpg,indexmethod="median")
beta.nshelf <- indexregionfunc(indexlist=x.methy450@NSHELFInd,
    beta=beta.cpg,indexmethod="median")
beta.sshelf <- indexregionfunc(indexlist=x.methy450@SSHELFInd,
    beta=beta.cpg,indexmethod="median")
@

<<regression, cache = TRUE, echo = FALSE, include = FALSE>>=
dim(mvalues)
pData$BASC_AP_HY <- rowMeans(cbind(pData$BASC_AP, pData$BASC_HY))
y_vars <- c("BASC_AP_HY", "BASC_AP", "BASC_HY", "BRF_ISCI", "BRF_FI", 
    "BRF_EMI", "BRF_GEC", "BRF_IN", "BRF_SF")

# b <- vector("list", length(y_vars))
# names(b) <- y_vars
# tval  <- vector("list", length(y_vars))
# names(tval) <- y_vars

lmbehav <- function(m, pdat, score) {
    xvars <- c("~pdat$age_mo_SR_Surv", "sex", "birthwt_kg", 
    "GestAge_weeks", "education_3cat", "Race3", "parity_3cat", 
    "mom_age_delv", "prePregBMIthreeLev", "asrs_ADHD_2cat")
    fmla<-paste('pdat$', score, paste(xvars, collapse = "+pdat$"), sep = "")
    fmla2 <- paste(fmla, "+pdat$mval")

    n_probes = dim(m)[1]
    pval_temp <- vector(mode = "numeric", length = n_probes)
    for (i in 1:n_probes) {
        pdat$mval <- m[i,]
        lm.out <- lm(as.formula(fmla2), data = pdat)
        pval_temp[i] <- coef(summary(lm.out))["pdat$mval", "Pr(>|t|)"]
    }
    # lm.out <- lm(pdat$BASC_AP_HY~pdat$age_mo_SR_Surv+pdat$sex+pdat$birthwt_kg+
    #      pdat$GestAge_weeks+pdat$education_3cat+pdat$Race3+pdat$parity_3cat+
    #      pdat$mom_age_delv+pdat$prePregBMIthreeLev+pdat$asrs_ADHD_2cat, data = pdat)
    
    return(pval_temp)
}

pData$mval <- NA

all_val_regr <- foreach (y = y_vars, .verbose = TRUE) %dopar% {lmbehav(mvalues, pData, y)}
length(all_val_regr)
names(all_val_regr)
attributes(all_val_regr)
@

<<pp_plots, cache = TRUE>>=
pvplot<-function(pvs=pvs.lp,titl=""){
    nlogpv<-sort(-log10(pvs[!is.na(pvs)]))
    n.use<-length(nlogpv)
    expctd<-((1:n.use)-0.5)/n.use
    expctd<-sort(-log10(expctd))
    par(pty="s")
    plot(nlogpv,expctd,pch=".",main=titl,las=1,
       cex=2,xlab="observed -log10(pv)",ylab="expected -log10(pv)")
    legend(x="bottomright",inset=0.03,
         legend=c("95% Pointwise Interval Under Null","Expected Under Null"),
         lty=c(1,1),col=c(3,2),lwd=c(4,4),cex=0.5)
    abline(a=0,b=1,col=2,lwd=2)
}
    for (i in 1:9){
        pvplot(all_val_regr[[i]], y_vars[i])
    }
@

<<summary_plots, dev = 'pdf', fig.width=4, fig.height=4, cache = TRUE, echo = TRUE>>=
#We need to combine the y_vals in the data frame and regress them at the same time
#We need to combine the x_vals in the 
behav_score <- pData[y_vars]

lmbehav2 <- function(m, pdat, scores) {
    cntrl <- c("~pdat$age_mo_SR_Surv", "sex", "birthwt_kg", 
    "GestAge_weeks", "education_3cat", "Race3", "parity_3cat", 
    "mom_age_delv", "prePregBMIthreeLev", "asrs_ADHD_2cat")
    
    regions <- c("exon1", "genebody", "island", 
    "nshelf", "nshore", "sshelf", "sshore",
    "tss1500", "tss200", "utr3", "utr5")
    
    fmla<-paste("pdat$", scores, 
        paste(cntrl, collapse = "+pdat$"), "+pdat$mval", sep = "")

    p.val <- vector(mode = "list", length = 11)
    names(p.val) <- regions
    for (j in regions){
        n_probes <- dim(m[[j]])[1]
        p.val[[j]] <- vector(mode= "numeric", length = n_probes)
        for (i in 1:n_probes) {
            pdat$mval <- m[[j]][i,]
            lm.out <- lm(as.formula(fmla), data = pdat)
            p.val[[j]][i] <- coef(summary(lm.out))["pdat$mval", "Pr(>|t|)"]
        }
    }
    return(p.val)
}

rm(beta.cpg, beta)
regions <- c("beta.exon1", "beta.genebody", "beta.island", 
    "beta.nshelf", "beta.nshore", "beta.sshelf", "beta.sshore",
    "beta.tss1500", "beta.tss200", "beta.utr3", "beta.utr5")

mval = list()
for(r in regions){
    mval.name = substring(r, 6) 
    mval[[mval.name]] = get(r)

}

p.sumryregr <- foreach (y = y_vars, .verbose = TRUE) %dopar% {lmbehav2(mval, pData, y)}
@

<<plots_of_p.sumryregr, dev = 'pdf', fig.width=4, fig.height=4, cache = TRUE, echo = TRUE>>=

reg <- c("exon1", "genebody", "island", 
    "nshelf", "nshore", "sshelf", "sshore",
    "tss1500", "tss200", "utr3", "utr5")

for (i in 1:9){
    for (r in reg){
    pvplot(p.sumryregr[[i]][[r]], paste(y_vars[[i]], r))
    }
}
@
\end{document}
